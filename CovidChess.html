<script type="text/javascript">
        var gk_isXlsx = false;
        var gk_xlsxFileLookup = {};
        var gk_fileData = {};
        function filledCell(cell) {
          return cell !== '' && cell != null;
        }
        function loadFileData(filename) {
        if (gk_isXlsx && gk_xlsxFileLookup[filename]) {
            try {
                var workbook = XLSX.read(gk_fileData[filename], { type: 'base64' });
                var firstSheetName = workbook.SheetNames[0];
                var worksheet = workbook.Sheets[firstSheetName];

                // Convert sheet to JSON to filter blank rows
                var jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, blankrows: false, defval: '' });
                // Filter out blank rows (rows where all cells are empty, null, or undefined)
                var filteredData = jsonData.filter(row => row.some(filledCell));

                // Heuristic to find the header row by ignoring rows with fewer filled cells than the next row
                var headerRowIndex = filteredData.findIndex((row, index) =>
                  row.filter(filledCell).length >= filteredData[index + 1]?.filter(filledCell).length
                );
                // Fallback
                if (headerRowIndex === -1 || headerRowIndex > 25) {
                  headerRowIndex = 0;
                }

                // Convert filtered JSON back to CSV
                var csv = XLSX.utils.aoa_to_sheet(filteredData.slice(headerRowIndex)); // Create a new sheet from filtered array of arrays
                csv = XLSX.utils.sheet_to_csv(csv, { header: 1 });
                return csv;
            } catch (e) {
                console.error(e);
                return "";
            }
        }
        return gk_fileData[filename] || "";
        }
        </script><!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8">
  <title>新冠肺炎棋</title>
  <style>
    body {
      display: flex;
      flex-direction: column;
      align-items: center;
      font-family: Arial, sans-serif;
      background-color: #f0f0f0;
    }
    h1 {
      font-size: 28px;
      color: #333;
      margin: 10px 0;
    }
    canvas {
      border: 2px solid #333;
      background-color: #fff;
    }
    #status {
      margin-top: 10px;
      font-size: 20px;
      color: #333;
    }
    #score {
      margin-top: 10px;
      font-size: 18px;
      color: #333;
    }
    #mode-selection, #game-controls {
      margin-top: 10px;
      display: flex;
      gap: 10px;
    }
    #author {
      margin-top: 10px;
      font-size: 16px;
      color: #666;
    }
    button {
      padding: 10px 20px;
      font-size: 16px;
      cursor: pointer;
      background-color: #4CAF50;
      color: white;
      border: none;
      border-radius: 5px;
    }
    button:hover {
      background-color: #45a049;
    }
    #rules-panel {
      display: none;
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background-color: white;
      padding: 20px;
      border: 2px solid #333;
      border-radius: 10px;
      max-width: 500px;
      max-height: 80vh;
      overflow-y: auto;
      z-index: 1000;
      box-shadow: 0 4px 8px rgba(0,0,0,0.2);
    }
    #rules-panel h2 {
      margin-top: 0;
      color: #333;
    }
    #rules-panel p {
      margin: 10px 0;
      line-height: 1.5;
    }
    #rules-panel button {
      background-color: #ff4444;
      margin-top: 10px;
    }
    #rules-panel button:hover {
      background-color: #cc0000;
    }
    #overlay {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0,0,0,0.5);
      z-index: 999;
    }
  </style>
</head>
<body>
  <h1>新冠肺炎棋</h1>
  <canvas id="board" width="350" height="350"></canvas>
  <div id="status">請選擇遊戲模式</div>
  <div id="score">紅方: 0 | 白方: 0</div>
  <div id="mode-selection">
    <button onclick="startGame('red')">扮演病毒（紅方）</button>
    <button onclick="startGame('white')">扮演醫護（白方）</button>
    <button onclick="startGame('two-player')">雙人遊戲</button>
  </div>
  <div id="game-controls" style="display: none;">
    <button id="rules" onclick="showRules()">規則說明</button>
    <button id="restart" onclick="resetToModeSelection()">重新開始</button>
  </div>
  <div id="author">2020 by FallCloud</div>
  <div id="overlay"></div>
  <div id="rules-panel">
    <h2>新冠肺炎棋規則</h2>
    <p><strong>1. 遊戲流程</strong></p>
    <p>紅方（病毒）先行，白方（醫護）後手，輪流行動至盤面填滿。若一方無可行動點，則由另一方繼續下棋，直到盤面填滿或雙方均無可行動點。</p>
    <p><strong>2. 紅方（病毒）步法</strong></p>
    <p>- <strong>擴散</strong>：落子於現有紅棋或變異紅棋周圍八格的空白處，落子後觸發「感染」，將相鄰四格（上下左右）的白棋翻為普通紅棋。<br>
       - <strong>變異</strong>：選擇一顆現有紅棋，將其變為變異紅棋（顯示為深紅色棋子並加粗黑圈），同時將相鄰四格（上下左右）的紅棋和白棋變為變異紅棋，每局僅可使用一次。變異紅棋不可被白方翻轉，且阻斷白方救治連線。<br>
       - 紅方必須優先選擇可感染白棋的擴散或變異步法（若未使用，優先級相同）；若兩者均無，則可選擇無感染效果的擴散或變異。</p>
    <p><strong>3. 白方（醫護）步法</strong></p>
    <p>- <strong>救治</strong>：依黑白棋規則落子，翻轉夾住的普通紅棋為白棋（沿八個方向，變異紅棋阻斷連線且不可翻轉）。<br>
       - <strong>支援</strong>：落子於現有白棋相鄰四格（上下左右）的空白處，無翻轉效果。</p>
    <p><strong>4. 棋盤設定</strong></p>
    <p>棋盤為7x7格，包含13個黑格（不可落子）：正中央1格、四角各3格（邊角及相鄰2格）。<br>
       初始棋子：紅棋在(3,3)和(5,5)，白棋在(3,5)和(5,3)。</p>
    <p><strong>5. 遊戲結束與計分</strong></p>
    <p>- 遊戲於盤面填滿或雙方均無可行動點時結束。<br>
       - 每顆棋（含變異紅棋）計1分，總得分高者勝，相同則平局。</p>
    <p>2020 by FallCloud</p>
    <button onclick="hideRules()">關閉</button>
  </div>
  <script>
    const canvas = document.getElementById('board');
    const ctx = canvas.getContext('2d');
    const statusDiv = document.getElementById('status');
    const scoreDiv = document.getElementById('score');
    const modeSelection = document.getElementById('mode-selection');
    const gameControls = document.getElementById('game-controls');
    const rulesPanel = document.getElementById('rules-panel');
    const overlay = document.getElementById('overlay');
    const cellSize = 50;
    const boardSize = 7;
    let board = [];
    let currentPlayer = 'red';
    let gameOver = false;
    let gameMode = null; // 'red' (玩家紅方), 'white' (玩家白方), 'two-player' (雙人)
    let aiPlayer = null; // 'red' 或 'white' 或 null
    let mutationUsed = false; // 追蹤變異步法是否已使用

    // 黑格位置：正中央 (3,3)，四角各3格
    const blackCells = [
      [0,0], [0,1], [1,0], // 左上
      [0,5], [0,6], [1,6], // 右上
      [5,0], [6,0], [6,1], // 左下
      [5,6], [6,5], [6,6], // 右下
      [3,3] // 中央
    ];

    // 位置權重：中心格子分數高，邊緣低
    const positionWeights = [
      [1, 1, 2, 2, 2, 1, 1],
      [1, 3, 3, 3, 3, 3, 1],
      [2, 3, 4, 4, 4, 3, 2],
      [2, 3, 4, 0, 4, 3, 2], // 中央(3,3)為黑格，權重為0
      [2, 3, 4, 4, 4, 3, 2],
      [1, 3, 3, 3, 3, 3, 1],
      [1, 1, 2, 2, 2, 1, 1]
    ];

    function initBoard() {
      board = Array(boardSize).fill().map(() => Array(boardSize).fill(null));
      blackCells.forEach(([r, c]) => board[r][c] = 'black');
      board[2][2] = 'red';   // 3-3
      board[4][4] = 'red';   // 5-5
      board[2][4] = 'white'; // 3-5
      board[4][2] = 'white'; // 5-3
      mutationUsed = false; // 重置變異步法使用狀態
    }

    function drawBoard() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      // 僅在遊戲未結束且為玩家回合時顯示可走步
      if (!gameOver && gameMode && (currentPlayer !== aiPlayer || gameMode === 'two-player')) {
        const validMoves = currentPlayer === 'red' ? getValidRedMoves() : getValidWhiteMoves();
        const moveMap = new Map();
        validMoves.forEach(move => {
          const key = `${move.r},${move.c}`;
          if (currentPlayer === 'white' && moveMap.has(key) && move.flipped.length > 0) {
            moveMap.set(key, 'rgba(0, 0, 255, 0.3)'); // 優先顯示救治（藍色）
          } else if (!moveMap.has(key)) {
            const color = currentPlayer === 'red' ?
                          (move.type === 'spread' ? 'rgba(255, 0, 0, 0.3)' : 'rgba(128, 0, 128, 0.3)') : // 紅方：擴散紅色，變異紫色
                          move.flipped.length > 0 ? 'rgba(0, 0, 255, 0.3)' : 'rgba(0, 255, 0, 0.3)'; // 白方：救治藍色，支援綠色
            moveMap.set(key, color);
          }
        });
        moveMap.forEach((color, key) => {
          const [r, c] = key.split(',').map(Number);
          const x = c * cellSize;
          const y = r * cellSize;
          ctx.fillStyle = color;
          ctx.fillRect(x, y, cellSize, cellSize);
        });
      }
      // 繪製棋盤和棋子
      for (let r = 0; r < boardSize; r++) {
        for (let c = 0; c < boardSize; c++) {
          const x = c * cellSize;
          const y = r * cellSize;
          ctx.strokeStyle = '#333';
          ctx.strokeRect(x, y, cellSize, cellSize);
          if (board[r][c] === 'black') {
            ctx.fillStyle = '#333';
            ctx.fillRect(x, y, cellSize, cellSize);
          } else if (board[r][c] === 'red') {
            ctx.fillStyle = '#ff0000';
            ctx.beginPath();
            ctx.arc(x + cellSize / 2, y + cellSize / 2, cellSize / 3, 0, Math.PI * 2);
            ctx.fill();
          } else if (board[r][c] === 'special_red') {
            ctx.fillStyle = '#8B0000'; // 變異紅棋：深紅色
            ctx.beginPath();
            ctx.arc(x + cellSize / 2, y + cellSize / 2, cellSize / 3, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 3; // 加粗黑圈
            ctx.stroke();
            ctx.lineWidth = 1; // 重置線條寬度
          } else if (board[r][c] === 'white') {
            ctx.fillStyle = '#ffffff';
            ctx.beginPath();
            ctx.arc(x + cellSize / 2, y + cellSize / 2, cellSize / 3, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#000';
            ctx.stroke();
          }
        }
      }
    }

    function isBlackCell(r, c) {
      return blackCells.some(([br, bc]) => br === r && bc === c);
    }

    function getValidRedMoves(tempBoard = board) {
      const priorityMoves = []; // 可感染白棋的擴散或變異步法
      const nonFlippingMoves = []; // 無感染效果的擴散或變異步法
      // 1. 檢查擴散步法
      for (let r = 0; r < boardSize; r++) {
        for (let c = 0; c < boardSize; c++) {
          if (tempBoard[r][c] !== null || isBlackCell(r, c)) continue;
          let flipped = [];
          let adjacentRed = false;
          // 檢查是否與紅棋或變異紅棋八格相鄰
          for (let dr = -1; dr <= 1; dr++) {
            for (let dc = -1; dc <= 1; dc++) {
              if (dr === 0 && dc === 0) continue;
              const nr = r + dr, nc = c + dc;
              if (nr >= 0 && nr < boardSize && nc >= 0 && nc < boardSize && (tempBoard[nr][nc] === 'red' || tempBoard[nr][nc] === 'special_red')) {
                adjacentRed = true;
                // 檢查感染效果（相鄰四格白棋）
                [[0,1], [0,-1], [1,0], [-1,0]].forEach(([ddr, ddc]) => {
                  const nnr = r + ddr, nnc = c + ddc;
                  if (nnr >= 0 && nnr < boardSize && nnc >= 0 && nnc < boardSize && tempBoard[nnr][nnc] === 'white') {
                    flipped.push([nnr, nnc]);
                  }
                });
                break;
              }
            }
          }
          if (adjacentRed) {
            const move = { r, c, flipped, type: 'spread' };
            if (flipped.length > 0) {
              priorityMoves.push(move);
            } else {
              nonFlippingMoves.push(move);
            }
          }
        }
      }
      // 2. 檢查變異步法（僅當未使用時）
      if (!mutationUsed) {
        for (let r = 0; r < boardSize; r++) {
          for (let c = 0; c < boardSize; c++) {
            if (tempBoard[r][c] !== 'red') continue; // 僅檢查普通紅棋
            let flipped = [];
            // 檢查四格相鄰的紅棋和白棋
            [[0,1], [0,-1], [1,0], [-1,0]].forEach(([dr, dc]) => {
              const nr = r + dr, nc = c + dc;
              if (nr >= 0 && nr < boardSize && nc >= 0 && nc < boardSize && (tempBoard[nr][nc] === 'red' || tempBoard[nr][nc] === 'white')) {
                flipped.push([nr, nc]);
              }
            });
            // 所有普通紅棋都可變異，即使無翻轉
            priorityMoves.push({ r, c, flipped, type: 'mutation' });
          }
        }
      }
      // 返回優先級高的步法（可感染白棋的擴散或任何變異），若無則返回無感染效果的擴散或變異
      return priorityMoves.length > 0 ? priorityMoves : nonFlippingMoves;
    }

    function getValidWhiteMoves(tempBoard = board) {
      const moves = [];
      // 1. 檢查救治步法（黑白棋規則，變異紅棋阻斷）
      for (let r = 0; r < boardSize; r++) {
        for (let c = 0; c < boardSize; c++) {
          if (tempBoard[r][c] !== null || isBlackCell(r, c)) continue;
          let flipped = [];
          [[0,1], [0,-1], [1,0], [-1,0], [1,1], [1,-1], [-1,1], [-1,-1]].forEach(([dr, dc]) => {
            let nr = r + dr, nc = c + dc;
            let line = [];
            while (nr >= 0 && nr < boardSize && nc >= 0 && nc < boardSize && tempBoard[nr][nc] === 'red') {
              line.push([nr, nc]);
              nr += dr;
              nc += dc;
            }
            if (nr >= 0 && nr < boardSize && nc >= 0 && nc < boardSize && tempBoard[nr][nc] === 'white' && line.length > 0) {
              flipped.push(...line);
            }
          });
          if (flipped.length > 0) {
            moves.push({ r, c, flipped, type: 'cure' });
          }
        }
      }
      // 2. 檢查支援步法（白棋相鄰四格）
      for (let r = 0; r < boardSize; r++) {
        for (let c = 0; c < boardSize; c++) {
          if (tempBoard[r][c] !== null || isBlackCell(r, c)) continue;
          for (let [dr, dc] of [[0,1], [0,-1], [1,0], [-1,0]]) {
            const nr = r + dr, nc = c + dc;
            if (nr >= 0 && nr < boardSize && nc >= 0 && nc < boardSize && tempBoard[nr][nc] === 'white') {
              if (!moves.some(m => m.r === r && m.c === c)) {
                moves.push({ r, c, flipped: [], type: 'support' });
              }
              break;
            }
          }
        }
      }
      return moves;
    }

    function makeMove(r, c, flipped, player, moveType) {
      if (moveType === 'mutation') {
        // 變異：將選中紅棋及其四格內紅白棋變為變異紅棋
        board[r][c] = 'special_red';
        flipped.forEach(([fr, fc]) => board[fr][fc] = 'special_red');
        mutationUsed = true;
      } else {
        // 擴散、救治或支援：落子並翻轉
        board[r][c] = player;
        flipped.forEach(([fr, fc]) => board[fr][fc] = player);
      }
      currentPlayer = currentPlayer === 'red' ? 'white' : 'red';
      updateStatus();
      drawBoard();
      checkGameOver();
      if (!gameOver && gameMode !== 'two-player' && currentPlayer === aiPlayer) {
        setTimeout(makeAIMove, 500);
      }
    }

    function evaluateMove(move, player) {
      let score = 0;
      // 1. 翻轉得分
      score += move.flipped.length * 2; // 每翻轉一顆紅白棋 +2
      if (move.type === 'mutation') {
        score += 3; // 變異額外加分（因生成變異紅棋）
        // 穩定性：變異紅棋靠近黑格加分
        let stability = 0;
        [[0,1], [0,-1], [1,0], [-1,0]].forEach(([dr, dc]) => {
          const nr = move.r + dr, nc = move.c + dc;
          if (nr >= 0 && nr < boardSize && nc >= 0 && nc < boardSize && isBlackCell(nr, nc)) {
            stability += 2;
          }
        });
        score += stability;
      } else {
        // 位置權重（僅擴散或白方步法）
        score += positionWeights[move.r][move.c];
      }
      // 2. 未來可走性
      const tempBoard = board.map(row => row.slice());
      if (move.type === 'mutation') {
        tempBoard[move.r][move.c] = 'special_red';
        move.flipped.forEach(([fr, fc]) => tempBoard[fr][fc] = 'special_red');
      } else {
        tempBoard[move.r][move.c] = player;
        move.flipped.forEach(([fr, fc]) => tempBoard[fr][fc] = player);
      }
      const opponent = player === 'red' ? 'white' : 'red';
      const opponentMoves = opponent === 'red' ? getValidRedMoves(tempBoard) : getValidWhiteMoves(tempBoard);
      score -= opponentMoves.length * 0.5;
      return score;
    }

    function makeAIMove() {
      if (gameOver) return;
      const validMoves = currentPlayer === 'red' ? getValidRedMoves() : getValidWhiteMoves();
      if (validMoves.length === 0) {
        currentPlayer = currentPlayer === 'red' ? 'white' : 'red';
        updateStatus();
        checkGameOver();
        return;
      }
      let bestMove = validMoves[0];
      let bestScore = evaluateMove(bestMove, currentPlayer);
      for (let i = 1; i < validMoves.length; i++) {
        const score = evaluateMove(validMoves[i], currentPlayer);
        if (score > bestScore) {
          bestScore = score;
          bestMove = validMoves[i];
        }
      }
      makeMove(bestMove.r, bestMove.c, bestMove.flipped, currentPlayer, bestMove.type);
    }

    function updateStatus() {
      if (gameOver) return;
      const redMoves = getValidRedMoves();
      const whiteMoves = getValidWhiteMoves();
      if (currentPlayer === 'red' && redMoves.length === 0) {
        if (whiteMoves.length > 0) {
          currentPlayer = 'white';
          statusDiv.textContent = '紅方無可行動點，白方繼續';
        } else {
          gameOver = true;
          checkGameOver();
        }
      } else if (currentPlayer === 'white' && whiteMoves.length === 0) {
        if (redMoves.length > 0) {
          currentPlayer = 'red';
          statusDiv.textContent = '白方無可行動點，紅方繼續';
        } else {
          gameOver = true;
          checkGameOver();
        }
      } else {
        statusDiv.textContent = currentPlayer === 'red' ? '紅方（病毒）回合' : '白方（醫護）回合';
      }
      updateScore();
    }

    function updateScore() {
      let redScore = 0, whiteScore = 0;
      for (let r = 0; r < boardSize; r++) {
        for (let c = 0; c < boardSize; c++) {
          if (board[r][c] === 'red' || board[r][c] === 'special_red') redScore++;
          else if (board[r][c] === 'white') whiteScore++;
        }
      }
      scoreDiv.textContent = `紅方: ${redScore} | 白方: ${whiteScore}`;
    }

    function checkGameOver() {
      if (!gameOver) return;
      let redScore = 0, whiteScore = 0;
      for (let r = 0; r < boardSize; r++) {
        for (let c = 0; c < boardSize; c++) {
          if (board[r][c] === 'red' || board[r][c] === 'special_red') redScore++;
          else if (board[r][c] === 'white') whiteScore++;
        }
      }
      let result = redScore > whiteScore ? '紅方（病毒）獲勝！' : redScore < whiteScore ? '白方（醫護）獲勝！' : '平局！';
      statusDiv.textContent = `遊戲結束！${result}`;
      scoreDiv.textContent = `最終得分 - 紅方: ${redScore} | 白方: ${whiteScore}`;
    }

    function showRules() {
      rulesPanel.style.display = 'block';
      overlay.style.display = 'block';
    }

    function hideRules() {
      rulesPanel.style.display = 'none';
      overlay.style.display = 'none';
    }

    function startGame(mode) {
      gameMode = mode;
      aiPlayer = mode === 'red' ? 'white' : mode === 'white' ? 'red' : null;
      modeSelection.style.display = 'none';
      gameControls.style.display = 'flex';
      initGame();
      if (gameMode === 'white' && currentPlayer === 'red') {
        setTimeout(makeAIMove, 500);
      }
    }

    function resetToModeSelection() {
      gameMode = null;
      aiPlayer = null;
      gameOver = false;
      modeSelection.style.display = 'flex';
      gameControls.style.display = 'none';
      statusDiv.textContent = '請選擇遊戲模式';
      initBoard();
      updateScore();
      drawBoard();
    }

    function initGame() {
      initBoard();
      currentPlayer = 'red';
      gameOver = false;
      updateStatus();
      drawBoard();
    }

    canvas.addEventListener('click', (e) => {
      if (gameOver || gameMode === null || (currentPlayer === aiPlayer && gameMode !== 'two-player')) return;
      const rect = canvas.getBoundingClientRect();
      const r = Math.floor((e.clientY - rect.top) / cellSize);
      const c = Math.floor((e.clientX - rect.left) / cellSize);
      if (r < 0 || r >= boardSize || c < 0 || c >= boardSize) return;
      const validMoves = currentPlayer === 'red' ? getValidRedMoves() : getValidWhiteMoves();
      const move = validMoves.find(m => m.r === r && m.c === c);
      if (move) {
        makeMove(r, c, move.flipped, currentPlayer, move.type);
      }
    });

    initGame();
  </script>
</body>
</html>